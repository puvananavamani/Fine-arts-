# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OK-QPAwtlTX3kaoYG0wKGyZWf-mFPiLM
"""

!pip install -q gradio langchain langchain-groq langchain-community langchain-text-splitters chromadb pypdf pandas openpyxl sentence-transformers --no-deps
!pip install -q langchain-core pydantic typing-extensions numpy

!pip install -q langchain langchain-groq langchain-community langchain-text-splitters chromadb pypdf pandas openpyxl sentence-transformers gradio

# RAG System with Groq LLM for Google Colab
# STEP 1: Run this installation command first:
# !pip install -q langchain langchain-groq langchain-community langchain-text-splitters chromadb pypdf pandas openpyxl sentence-transformers gradio

import gradio as gr
import os
from typing import List, Tuple
import pandas as pd
from langchain_text_splitters import RecursiveCharacterTextSplitter
from langchain_community.document_loaders import PyPDFLoader, TextLoader
from langchain_community.vectorstores import Chroma
from langchain_community.embeddings import HuggingFaceEmbeddings
from langchain_groq import ChatGroq
from langchain_core.documents import Document
from langchain_core.prompts import ChatPromptTemplate

class RAGSystem:
    def __init__(self):
        self.vectorstore = None
        self.retriever = None
        self.llm = None
        self.groq_api_key = None
        self.embeddings = HuggingFaceEmbeddings(
            model_name="sentence-transformers/all-MiniLM-L6-v2"
        )
        self.documents = []

    def verify_api_key(self, api_key: str) -> Tuple[str, str]:
        """Verify if the Groq API key is valid"""
        try:
            if not api_key or api_key.strip() == "":
                return "‚ùå API Key is empty. Please provide a valid key.", "error"

            # Test the API key with a simple request
            llm = ChatGroq(
                groq_api_key=api_key,
                model_name="llama-3.3-70b-versatile",
                temperature=0
            )

            # Make a test call
            response = llm.invoke("Say 'API key verified'")

            self.groq_api_key = api_key
            self.llm = llm
            return "‚úÖ API Key verified successfully! You can now upload documents.", "success"

        except Exception as e:
            error_msg = str(e)
            if "401" in error_msg or "authentication" in error_msg.lower():
                return "‚ùå Invalid API Key. Please check your Groq API key.", "error"
            else:
                return f"‚ùå Error verifying API key: {error_msg}", "error"

    def load_pdf(self, file_path: str) -> List[Document]:
        """Load PDF documents"""
        loader = PyPDFLoader(file_path)
        return loader.load()

    def load_text(self, file_path: str) -> List[Document]:
        """Load text documents"""
        loader = TextLoader(file_path, encoding='utf-8')
        return loader.load()

    def load_excel(self, file_path: str) -> List[Document]:
        """Load Excel documents"""
        df = pd.read_excel(file_path)
        # Convert dataframe to text format
        text_content = df.to_string()
        return [Document(page_content=text_content, metadata={"source": file_path})]

    def process_documents(self, files) -> str:
        """Process uploaded documents"""
        if not self.groq_api_key:
            return "‚ùå Please verify your API key first!"

        if not files:
            return "‚ùå Please upload at least one document!"

        try:
            all_docs = []

            for file in files:
                file_path = file.name
                file_extension = os.path.splitext(file_path)[1].lower()

                if file_extension == '.pdf':
                    docs = self.load_pdf(file_path)
                elif file_extension == '.txt':
                    docs = self.load_text(file_path)
                elif file_extension in ['.xlsx', '.xls']:
                    docs = self.load_excel(file_path)
                else:
                    continue

                all_docs.extend(docs)

            if not all_docs:
                return "‚ùå No valid documents found. Please upload PDF, TXT, or Excel files."

            # Split documents into chunks
            text_splitter = RecursiveCharacterTextSplitter(
                chunk_size=1000,
                chunk_overlap=200,
                length_function=len
            )

            splits = text_splitter.split_documents(all_docs)
            self.documents = splits

            # Create vector store
            self.vectorstore = Chroma.from_documents(
                documents=splits,
                embedding=self.embeddings,
                collection_name="rag_collection"
            )

            # Create retriever
            self.retriever = self.vectorstore.as_retriever(
                search_kwargs={"k": 4}
            )

            return f"‚úÖ Successfully processed {len(files)} file(s) with {len(splits)} text chunks!"

        except Exception as e:
            return f"‚ùå Error processing documents: {str(e)}"

    def answer_question(self, question: str, history: List) -> str:
        """Answer questions based on uploaded documents"""
        if not self.groq_api_key:
            return "‚ùå Please verify your API key first!"

        if not self.retriever:
            return "‚ùå Please upload and process documents first!"

        if not question or question.strip() == "":
            return "‚ùå Please enter a question!"

        try:
            # Retrieve relevant documents
            relevant_docs = self.retriever.invoke(question)

            # Create context from retrieved documents
            context = "\n\n".join([doc.page_content for doc in relevant_docs])

            # Create prompt
            prompt_template = """You are a helpful assistant that answers questions based on the provided context.
Use the following context to answer the question. If you cannot find the answer in the context, say so.

Context:
{context}

Question: {question}

Answer:"""

            prompt = ChatPromptTemplate.from_template(prompt_template)
            formatted_prompt = prompt.format(context=context, question=question)

            # Get answer from LLM
            response = self.llm.invoke(formatted_prompt)
            answer = response.content

            # Add source information
            if relevant_docs:
                answer += "\n\nüìö **Sources:**\n"
                seen_sources = set()
                for doc in relevant_docs[:3]:  # Limit to top 3 sources
                    source = doc.metadata.get('source', 'Unknown')
                    if source not in seen_sources:
                        answer += f"- {os.path.basename(source)}\n"
                        seen_sources.add(source)

            return answer

        except Exception as e:
            return f"‚ùå Error answering question: {str(e)}"

# Initialize RAG system
rag_system = RAGSystem()

# Create Gradio interface
with gr.Blocks(title="RAG System with Groq LLM", theme=gr.themes.Soft()) as demo:
    gr.Markdown(
        """
        # ü§ñ RAG System with Groq LLM
        ### Upload documents (PDF, Excel, Text) and ask questions!
        """
    )

    with gr.Row():
        with gr.Column(scale=2):
            api_key_input = gr.Textbox(
                label="Groq API Key",
                placeholder="Enter your Groq API key here...",
                type="password"
            )
        with gr.Column(scale=1):
            verify_btn = gr.Button("üîë Verify API Key", variant="primary")

    api_status = gr.Textbox(label="API Key Status", interactive=False)

    gr.Markdown("---")

    with gr.Row():
        file_upload = gr.File(
            label="üìÅ Upload Documents (PDF, TXT, XLSX)",
            file_count="multiple",
            file_types=[".pdf", ".txt", ".xlsx", ".xls"]
        )

    process_btn = gr.Button("üì§ Process Documents", variant="primary", size="lg")
    process_status = gr.Textbox(label="Processing Status", interactive=False)

    gr.Markdown("---")
    gr.Markdown("### üí¨ Ask Questions About Your Documents")

    chatbot = gr.Chatbot(label="Chat History", height=400)

    with gr.Row():
        question_input = gr.Textbox(
            label="Your Question",
            placeholder="Ask anything about your uploaded documents...",
            scale=4
        )
        submit_btn = gr.Button("Send üì®", variant="primary", scale=1)

    clear_btn = gr.Button("üóëÔ∏è Clear Chat History")

    gr.Markdown(
        """
        ---
        ### üìù Instructions:
        1. Enter your Groq API key and click "Verify API Key"
        2. Upload one or more documents (PDF, TXT, or Excel files)
        3. Click "Process Documents" to index your files
        4. Start asking questions about your documents!

        **Note:** Get your free Groq API key from [console.groq.com](https://console.groq.com)
        """
    )

    # Event handlers
    def verify_key(api_key):
        status, status_type = rag_system.verify_api_key(api_key)
        return status

    def process_files(files):
        return rag_system.process_documents(files)

    def respond(message, chat_history):
        if not message.strip():
            return chat_history, ""

        bot_response = rag_system.answer_question(message, chat_history)
        chat_history.append((message, bot_response))
        return chat_history, ""

    def clear_chat():
        return [], ""

    # Connect events
    verify_btn.click(
        fn=verify_key,
        inputs=[api_key_input],
        outputs=[api_status]
    )

    process_btn.click(
        fn=process_files,
        inputs=[file_upload],
        outputs=[process_status]
    )

    submit_btn.click(
        fn=respond,
        inputs=[question_input, chatbot],
        outputs=[chatbot, question_input]
    )

    question_input.submit(
        fn=respond,
        inputs=[question_input, chatbot],
        outputs=[chatbot, question_input]
    )

    clear_btn.click(
        fn=clear_chat,
        inputs=[],
        outputs=[chatbot, question_input]
    )

# Launch the app
if __name__ == "__main__":
    demo.launch(debug=True, share=True)